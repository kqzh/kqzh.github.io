<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-31T11:17:09.725Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>KQZH</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CBC 文件加解密</title>
    <link href="http://yoursite.com/2020/03/30/CBC%20%E6%96%87%E4%BB%B6%E5%8A%A0%E8%A7%A3%E5%AF%86/"/>
    <id>http://yoursite.com/2020/03/30/CBC%20%E6%96%87%E4%BB%B6%E5%8A%A0%E8%A7%A3%E5%AF%86/</id>
    <published>2020-03-30T05:54:00.000Z</published>
    <updated>2020-03-31T11:17:09.725Z</updated>
    
    <content type="html"><![CDATA[<h2 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h2><p>借助cli做一个命令行工具，可以对所有类型的文件进行加解密，并支持输入自定义的 key 和 iv<br>通过字节流读取文件，加解密采用上篇文章实现的 <a href="https://kqzh.github.io/2020/03/28/SM4%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">sm4算法</a>，加密文件按照 <font color="grey">[iv][hashed key][密文…]</font>  格式进行组合</p><h2 id="CBC-介绍"><a href="#CBC-介绍" class="headerlink" title="CBC 介绍"></a>CBC 介绍</h2><p>CBC 全称为密码分组链接（Cipher Block Chaining）模式，即每个明文块先与前一个密文块进行异或后，再进行加密，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量 iv</p><h3 id="加密模式"><a href="#加密模式" class="headerlink" title="加密模式"></a>加密模式</h3><p><img src="/2020/03/30/CBC%20%E6%96%87%E4%BB%B6%E5%8A%A0%E8%A7%A3%E5%AF%86/cbc_enc.jfif" alt="cbc_enc"></p><h3 id="解密模式"><a href="#解密模式" class="headerlink" title="解密模式"></a>解密模式</h3><p><img src="/2020/03/30/CBC%20%E6%96%87%E4%BB%B6%E5%8A%A0%E8%A7%A3%E5%AF%86/cbc_dec.jfif" alt="cbc_dec"></p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这里给出了 cbc 加解密的具体实现，完整代码见<a href="https://github.com/kqzh/gm" target="_blank" rel="noopener">代码仓库</a></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Encrypt</span><span class="params">(file, key, iv <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>)</span><br><span class="line">fileSuffix := path.Ext(file) <span class="comment">//获取文件后缀</span></span><br><span class="line"></span><br><span class="line">data, err := ioutil.ReadFile(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">IV, err := hex.DecodeString(iv)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"iv decode err :"</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line">res = <span class="built_in">append</span>(res, IV...) <span class="comment">// 加密文件[0,16)表示iv</span></span><br><span class="line"></span><br><span class="line">KEY, err := hex.DecodeString(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"key decode err :"</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line">sum := sha256.Sum256(KEY)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; BlockSize; i++ &#123; <span class="comment">// 加密文件[16,32)表示hash之后的key</span></span><br><span class="line">res = <span class="built_in">append</span>(res, sum[i])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data = sm4.Padding(data, BlockSize) <span class="comment">// 尾部填充</span></span><br><span class="line">n := <span class="built_in">len</span>(data)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; n; i += BlockSize &#123; <span class="comment">// CBC加密</span></span><br><span class="line">text := data[i : i+BlockSize]</span><br><span class="line">process(text, IV)</span><br><span class="line">IV = sm4.Encrypt(text, KEY)</span><br><span class="line">res = <span class="built_in">append</span>(res, IV...)</span><br><span class="line">&#125;</span><br><span class="line">err = ioutil.WriteFile(<span class="string">"tmp"</span>+fileSuffix, res, <span class="number">0644</span>) <span class="comment">//创建加密后的文件tmp</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Decrypt</span><span class="params">(file, key <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line">res := <span class="built_in">make</span>([]<span class="keyword">byte</span>, <span class="number">0</span>)</span><br><span class="line">fileSuffix := path.Ext(file) <span class="comment">//获取文件后缀</span></span><br><span class="line"></span><br><span class="line">data, err := ioutil.ReadFile(file)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">n := <span class="built_in">len</span>(data)</span><br><span class="line"></span><br><span class="line">IV := data[:BlockSize]</span><br><span class="line">KEY, err := hex.DecodeString(key)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(<span class="string">"key decode err :"</span> + err.Error())</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">sum := sha256.Sum256(KEY)</span><br><span class="line"><span class="keyword">for</span> i := BlockSize; i &lt; BlockSize*<span class="number">2</span>; i++ &#123; <span class="comment">// 判断加解密的key是否相同</span></span><br><span class="line"><span class="keyword">if</span> sum[i-BlockSize] != data[i] &#123;</span><br><span class="line">log.Fatal(<span class="string">"you use wrong key"</span>)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">2</span> * BlockSize; i &lt; n; i += BlockSize &#123; <span class="comment">// CBC解密</span></span><br><span class="line">sText := data[i : i+BlockSize]</span><br><span class="line">text := sm4.Decrpty(sText, KEY)</span><br><span class="line">process(text, IV)</span><br><span class="line">IV = sText</span><br><span class="line">res = <span class="built_in">append</span>(res, text...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">err = ioutil.WriteFile(<span class="string">"result"</span>+fileSuffix, sm4.UnPadding(res), <span class="number">0644</span>) <span class="comment">//创建解密后的文件result</span></span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;想法&quot;&gt;&lt;a href=&quot;#想法&quot; class=&quot;headerlink&quot; title=&quot;想法&quot;&gt;&lt;/a&gt;想法&lt;/h2&gt;&lt;p&gt;借助cli做一个命令行工具，可以对所有类型的文件进行加解密，并支持输入自定义的 key 和 iv&lt;br&gt;通过字节流读取文件，加解密采用上篇文
      
    
    </summary>
    
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
      <category term="Crypto" scheme="http://yoursite.com/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>SM4 算法实现</title>
    <link href="http://yoursite.com/2020/03/28/SM4%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/03/28/SM4%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-03-28T04:11:00.000Z</published>
    <updated>2020-03-31T11:17:22.166Z</updated>
    
    <content type="html"><![CDATA[<h2 id="SM4-介绍"><a href="#SM4-介绍" class="headerlink" title="SM4 介绍"></a>SM4 介绍</h2><p>SM4 算法是中华人民共和国政府采用的一种分组密码标准，由国家密码管理局于2012年3月21日发布。相关标准为“<a href="http://www.gmbz.org.cn/main/viewfile/20180108015408199368.html" target="_blank" rel="noopener">GM/T 0002-2012《SM4分组密码算法》</a>”。本质是一个对称分组加密算法，类似于 DES 或者 AES。它的的分组长度为 128bit，密钥长度为 128bit。算法先由已知秘钥生成轮秘钥 rk，然后与被 S-box 加密后的明文 X 进行 32 轮轮变换，生成密文。解密只需将轮秘钥倒序再进行 32 轮轮变换即可，<a href="https://github.com/kqzh/gm/tree/master/sm4" target="_blank" rel="noopener">代码仓库</a></p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">S</span><span class="params">(a <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123; <span class="comment">// 通过S盒置换字</span></span><br><span class="line"><span class="keyword">var</span> aArr [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line"><span class="keyword">var</span> bArr [<span class="number">4</span>]<span class="keyword">byte</span></span><br><span class="line">binary.BigEndian.PutUint32(aArr[:], a)</span><br><span class="line">bArr[<span class="number">0</span>] = sBox[aArr[<span class="number">0</span>]]</span><br><span class="line">bArr[<span class="number">1</span>] = sBox[aArr[<span class="number">1</span>]]</span><br><span class="line">bArr[<span class="number">2</span>] = sBox[aArr[<span class="number">2</span>]]</span><br><span class="line">bArr[<span class="number">3</span>] = sBox[aArr[<span class="number">3</span>]]</span><br><span class="line"><span class="keyword">return</span> binary.BigEndian.Uint32(bArr[:])</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">L</span><span class="params">(b <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123; <span class="comment">// L变换</span></span><br><span class="line"><span class="keyword">return</span> b ^ bits.RotateLeft32(b, <span class="number">2</span>) ^ bits.RotateLeft32(b, <span class="number">10</span>) ^</span><br><span class="line">bits.RotateLeft32(b, <span class="number">18</span>) ^ bits.RotateLeft32(b, <span class="number">24</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">T</span><span class="params">(z <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123; <span class="comment">// T变换</span></span><br><span class="line"><span class="keyword">return</span> L(S(z))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">lRk</span><span class="params">(b <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123; <span class="comment">// rk的L变换</span></span><br><span class="line"><span class="keyword">return</span> b ^ bits.RotateLeft32(b, <span class="number">13</span>) ^ bits.RotateLeft32(b, <span class="number">23</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">tRk</span><span class="params">(z <span class="keyword">uint32</span>)</span> <span class="title">uint32</span></span> &#123; <span class="comment">// rk的T变换</span></span><br><span class="line"><span class="keyword">return</span> lRk(S(z))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(a []<span class="keyword">uint32</span>)</span></span> &#123; <span class="comment">//反转数组</span></span><br><span class="line">a[<span class="number">0</span>], a[<span class="number">3</span>] = a[<span class="number">3</span>], a[<span class="number">0</span>]</span><br><span class="line">a[<span class="number">1</span>], a[<span class="number">2</span>] = a[<span class="number">2</span>], a[<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">expandKey</span><span class="params">(key []<span class="keyword">byte</span>)</span> []<span class="title">uint32</span></span> &#123; <span class="comment">// 生成轮秘钥rk</span></span><br><span class="line">mK := <span class="built_in">make</span>([]<span class="keyword">uint32</span>, <span class="number">4</span>)</span><br><span class="line">mK[<span class="number">0</span>] = binary.BigEndian.Uint32(key[<span class="number">0</span>:<span class="number">4</span>]) <span class="comment">// 将四个字节转为一个字</span></span><br><span class="line">mK[<span class="number">1</span>] = binary.BigEndian.Uint32(key[<span class="number">4</span>:<span class="number">8</span>])</span><br><span class="line">mK[<span class="number">2</span>] = binary.BigEndian.Uint32(key[<span class="number">8</span>:<span class="number">12</span>])</span><br><span class="line">mK[<span class="number">3</span>] = binary.BigEndian.Uint32(key[<span class="number">12</span>:<span class="number">16</span>])</span><br><span class="line"></span><br><span class="line">k := <span class="built_in">make</span>([]<span class="keyword">uint32</span>, <span class="number">36</span>)</span><br><span class="line">k[<span class="number">0</span>] = mK[<span class="number">0</span>] ^ fK[<span class="number">0</span>] <span class="comment">// 主密钥与中系统参数fk异或得到中间数据k</span></span><br><span class="line">k[<span class="number">1</span>] = mK[<span class="number">1</span>] ^ fK[<span class="number">1</span>]</span><br><span class="line">k[<span class="number">2</span>] = mK[<span class="number">2</span>] ^ fK[<span class="number">2</span>]</span><br><span class="line">k[<span class="number">3</span>] = mK[<span class="number">3</span>] ^ fK[<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">rk := <span class="built_in">make</span>([]<span class="keyword">uint32</span>, <span class="number">32</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">32</span>; i++ &#123; <span class="comment">// 计算rk[i]</span></span><br><span class="line">k[i+<span class="number">4</span>] = k[i] ^ tRk(k[i+<span class="number">1</span>]^k[i+<span class="number">2</span>]^k[i+<span class="number">3</span>]^cK[i])</span><br><span class="line">rk[i] = k[i+<span class="number">4</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> rk</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">initX</span><span class="params">(text []<span class="keyword">byte</span>)</span> []<span class="title">uint32</span></span> &#123; <span class="comment">// 初始化x</span></span><br><span class="line">x := <span class="built_in">make</span>([]<span class="keyword">uint32</span>, <span class="number">36</span>)</span><br><span class="line">x[<span class="number">0</span>] = binary.BigEndian.Uint32(text[<span class="number">0</span>:<span class="number">4</span>])</span><br><span class="line">x[<span class="number">1</span>] = binary.BigEndian.Uint32(text[<span class="number">4</span>:<span class="number">8</span>])</span><br><span class="line">x[<span class="number">2</span>] = binary.BigEndian.Uint32(text[<span class="number">8</span>:<span class="number">12</span>])</span><br><span class="line">x[<span class="number">3</span>] = binary.BigEndian.Uint32(text[<span class="number">12</span>:<span class="number">16</span>])</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">encrypt</span><span class="params">(x []<span class="keyword">uint32</span>, rk []<span class="keyword">uint32</span>)</span> []<span class="title">uint32</span></span> &#123; <span class="comment">// 加密操作：32次轮函数 + 1次反转</span></span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">32</span>; i++ &#123;</span><br><span class="line">x[i+<span class="number">4</span>] = x[i] ^ T(x[i+<span class="number">1</span>]^x[i+<span class="number">2</span>]^x[i+<span class="number">3</span>]^rk[i])</span><br><span class="line">&#125;</span><br><span class="line">reverse(x[<span class="number">32</span>:])</span><br><span class="line"><span class="keyword">return</span> x[<span class="number">32</span>:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">decrypt</span><span class="params">(res []<span class="keyword">uint32</span>, rk []<span class="keyword">uint32</span>)</span> []<span class="title">uint32</span></span> &#123; <span class="comment">// 解密操作：32次轮函数(rk 从后往前) + 1次反转</span></span><br><span class="line">x := <span class="built_in">make</span>([]<span class="keyword">uint32</span>, <span class="number">36</span>)</span><br><span class="line">x[<span class="number">0</span>] = res[<span class="number">0</span>] <span class="comment">//将res转移为新的x</span></span><br><span class="line">x[<span class="number">1</span>] = res[<span class="number">1</span>]</span><br><span class="line">x[<span class="number">2</span>] = res[<span class="number">2</span>]</span><br><span class="line">x[<span class="number">3</span>] = res[<span class="number">3</span>]</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">32</span>; i++ &#123;</span><br><span class="line">x[i+<span class="number">4</span>] = x[i] ^ T(x[i+<span class="number">1</span>]^x[i+<span class="number">2</span>]^x[i+<span class="number">3</span>]^rk[<span class="number">31</span>-i])</span><br><span class="line">&#125;</span><br><span class="line">reverse(x[<span class="number">32</span>:])</span><br><span class="line"><span class="keyword">return</span> x[<span class="number">32</span>:]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Padding</span><span class="params">(text []<span class="keyword">byte</span>, blockSize <span class="keyword">int</span>)</span> []<span class="title">byte</span></span> &#123; <span class="comment">// 尾部填充</span></span><br><span class="line">length := blockSize - <span class="built_in">len</span>(text)%blockSize</span><br><span class="line">padText := bytes.Repeat([]<span class="keyword">byte</span>&#123;<span class="keyword">byte</span>(length)&#125;, length)</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">append</span>(text, padText...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">UnPadding</span><span class="params">(text []<span class="keyword">byte</span>)</span> []<span class="title">byte</span></span> &#123; <span class="comment">// 删除填充</span></span><br><span class="line">length := <span class="built_in">len</span>(text)</span><br><span class="line">padLength := <span class="keyword">int</span>(text[length<span class="number">-1</span>])</span><br><span class="line"><span class="keyword">return</span> text[:(length - padLength)]</span><br><span class="line">&#125;</span><br><span class="line">© <span class="number">2020</span> GitHub, Inc.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;SM4-介绍&quot;&gt;&lt;a href=&quot;#SM4-介绍&quot; class=&quot;headerlink&quot; title=&quot;SM4 介绍&quot;&gt;&lt;/a&gt;SM4 介绍&lt;/h2&gt;&lt;p&gt;SM4 算法是中华人民共和国政府采用的一种分组密码标准，由国家密码管理局于2012年3月21日发布。相关标准
      
    
    </summary>
    
    
    
      <category term="Golang" scheme="http://yoursite.com/tags/Golang/"/>
    
      <category term="Crypto" scheme="http://yoursite.com/tags/Crypto/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://yoursite.com/2020/03/27/hello-world/"/>
    <id>http://yoursite.com/2020/03/27/hello-world/</id>
    <published>2020-03-27T09:31:34.000Z</published>
    <updated>2020-03-31T09:46:56.830Z</updated>
    
    <content type="html"><![CDATA[<p>REPOST</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">"fmt"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">fmt.Println(<span class="string">"hello, world"</span>)</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;REPOST&lt;/p&gt;
&lt;figure class=&quot;highlight go&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;
      
    
    </summary>
    
    
    
  </entry>
  
</feed>

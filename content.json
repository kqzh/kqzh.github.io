{"meta":{"title":"Hexo","subtitle":"","description":"","author":"KQZH","url":"http://yoursite.com","root":"/"},"pages":[{"title":"关于","date":"2020-03-31T12:20:05.353Z","updated":"2020-03-31T12:20:05.353Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"1234567891011121314type introduction map[string]interface&#123;&#125;foxman := introduction&#123; \"name\": \"foxman\", \"age\": 21, \"gender\": \"male\", \"base\": \"Hangzhou\", \"blog\": \"liuxinc.ink\", \"github\": \"github.com/kqzh\", \"language\": []string&#123;\"golang\", \"java\", \"javascipts\"&#125;, \"ops\": []string&#123;\"docker\", \"kubernetes\", \"linux\"&#125;, \"utils\": []string&#123;\"git\", \"wireshark\"&#125;, \"hobbies\": []string&#123;\"acm\", \"basketball\", \"starcraft\"&#125;,&#125;"},{"title":"Links","date":"2020-03-27T14:10:07.484Z","updated":"2020-03-27T14:10:07.484Z","comments":true,"path":"links/index.html","permalink":"http://yoursite.com/links/index.html","excerpt":"","text":""},{"title":"Records","date":"2020-03-31T09:12:38.124Z","updated":"2020-03-31T09:12:38.124Z","comments":false,"path":"records/index.html","permalink":"http://yoursite.com/records/index.html","excerpt":"","text":""},{"title":"Categories","date":"2020-03-27T10:00:24.339Z","updated":"2020-03-27T10:00:24.339Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"Repository","date":"2020-03-31T08:35:30.334Z","updated":"2020-03-27T10:01:26.256Z","comments":false,"path":"repository/index.html","permalink":"http://yoursite.com/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-31T08:52:05.086Z","updated":"2020-03-31T08:52:05.086Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"RKE 部署 Kubernetes","slug":"RKE 部署 Kubernetes","date":"2020-03-31T13:52:52.000Z","updated":"2020-03-31T15:11:29.243Z","comments":true,"path":"2020/03/31/RKE 部署 Kubernetes/","link":"","permalink":"http://yoursite.com/2020/03/31/RKE%20%E9%83%A8%E7%BD%B2%20Kubernetes/","excerpt":"","text":"节点规划 IP Role 192.168.0.10 rke部署节点 192.168.0.11 control plane, etcd, worker 规划说明：单独选择了一台服务器192.168.0.10作为部署节点，在部署节点上使用rke为目标服务器192.168.0.11安装最小的Kubernetes环境，两台机器的操作系统均为 CentOS 环境准备 安装 RKE - 需要在部署节点（192.168.0.10）上安装 RKE 二进制包，官方链接 创建非 root 用户 - 需要在目标节点（192.168.0.11）上创建非 root 用户，用来与部署节点进行 SSH 连接 123groupadd dockeruseradd docker_userusermod -aG docker docker_user 配置 SSH 免密登录 - 由于 RKE 通过 SSH tunnel 技术安装部署 k8s 集群，需要配置 RKE 所在节点到 k8s 各节点的 SSH 免密登录。（如果 RKE 所在节点也需要加入到 k8s 集群中，需要配置到本机的 SSH 免密登录） 1234# 在192.168.0.10上创建秘钥ssh-keygen# 将生成秘钥的公钥分发给各个节点ssh-copy-id docker_user@192.168.0.11 安装 docker - 由于 RKE 通过 docker 镜像rancher/hyperkube启动 k8s 组件，因此需要在 k8s 集群的各个节点上安装 docker，需注意要安装 k8s 支持的 docker 版本 12345678# 安装yum仓库管理工具yum install -y yum-utils# 下载阿里的docker-ce仓库yum-config-manager --add-repo https://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo# 查看选择docker-ce各版本yum list docker-ce --showduplicates|sort –r# 安装指定版本的docker-ceyum install docker-ce-18.06.1.ce -y 关闭 swap - k8s 1.8 开始要求关闭系统的 swap，如果不关闭，默认配置下 kubelet 将无法启动。这里需要关闭所有 k8s worker 节点的 swap 12vi /etc/fstab# 注释掉 swap 有关行 配置 cluster.yml关于cluster的详细说明，可以查看官方链接，这里展示一下我的 cluster.yml 配置 12345678nodes: - address: 192.168.0.11 user: docker_user role: - controlplane - etcd - worker ssh_key_path: /root/.ssh/id_rsa 部署 kubernetes 集群当 cluster.yml 文件配置完成后，可以通过命令./rke up完成集群的部署任务","categories":[],"tags":[],"author":"KQZH"},{"title":"CBC 文件加解密","slug":"CBC 文件加解密","date":"2020-03-30T05:54:00.000Z","updated":"2020-03-31T11:17:09.725Z","comments":true,"path":"2020/03/30/CBC 文件加解密/","link":"","permalink":"http://yoursite.com/2020/03/30/CBC%20%E6%96%87%E4%BB%B6%E5%8A%A0%E8%A7%A3%E5%AF%86/","excerpt":"","text":"想法借助cli做一个命令行工具，可以对所有类型的文件进行加解密，并支持输入自定义的 key 和 iv通过字节流读取文件，加解密采用上篇文章实现的 sm4算法，加密文件按照 [iv][hashed key][密文…] 格式进行组合 CBC 介绍CBC 全称为密码分组链接（Cipher Block Chaining）模式，即每个明文块先与前一个密文块进行异或后，再进行加密，为了保证每条消息的唯一性，在第一个块中需要使用初始化向量 iv 加密模式 解密模式 代码实现这里给出了 cbc 加解密的具体实现，完整代码见代码仓库 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374func Encrypt(file, key, iv string) &#123; res := make([]byte, 0) fileSuffix := path.Ext(file) //获取文件后缀 data, err := ioutil.ReadFile(file) if err != nil &#123; log.Fatal(err) &#125; IV, err := hex.DecodeString(iv) if err != nil &#123; log.Fatal(\"iv decode err :\" + err.Error()) &#125; res = append(res, IV...) // 加密文件[0,16)表示iv KEY, err := hex.DecodeString(key) if err != nil &#123; log.Fatal(\"key decode err :\" + err.Error()) &#125; sum := sha256.Sum256(KEY) for i := 0; i &lt; BlockSize; i++ &#123; // 加密文件[16,32)表示hash之后的key res = append(res, sum[i]) &#125; data = sm4.Padding(data, BlockSize) // 尾部填充 n := len(data) for i := 0; i &lt; n; i += BlockSize &#123; // CBC加密 text := data[i : i+BlockSize] process(text, IV) IV = sm4.Encrypt(text, KEY) res = append(res, IV...) &#125; err = ioutil.WriteFile(\"tmp\"+fileSuffix, res, 0644) //创建加密后的文件tmp if err != nil &#123; log.Fatal(err) &#125;&#125;func Decrypt(file, key string) &#123; res := make([]byte, 0) fileSuffix := path.Ext(file) //获取文件后缀 data, err := ioutil.ReadFile(file) if err != nil &#123; log.Fatal(err) &#125; n := len(data) IV := data[:BlockSize] KEY, err := hex.DecodeString(key) if err != nil &#123; log.Fatal(\"key decode err :\" + err.Error()) &#125; sum := sha256.Sum256(KEY) for i := BlockSize; i &lt; BlockSize*2; i++ &#123; // 判断加解密的key是否相同 if sum[i-BlockSize] != data[i] &#123; log.Fatal(\"you use wrong key\") &#125; &#125; for i := 2 * BlockSize; i &lt; n; i += BlockSize &#123; // CBC解密 sText := data[i : i+BlockSize] text := sm4.Decrpty(sText, KEY) process(text, IV) IV = sText res = append(res, text...) &#125; err = ioutil.WriteFile(\"result\"+fileSuffix, sm4.UnPadding(res), 0644) //创建解密后的文件result if err != nil &#123; log.Fatal(err) &#125;&#125;","categories":[],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://yoursite.com/tags/Golang/"},{"name":"Crypto","slug":"Crypto","permalink":"http://yoursite.com/tags/Crypto/"}],"author":"kqzh"},{"title":"SM4 算法实现","slug":"SM4算法实现","date":"2020-03-28T04:11:00.000Z","updated":"2020-03-31T11:17:22.166Z","comments":true,"path":"2020/03/28/SM4算法实现/","link":"","permalink":"http://yoursite.com/2020/03/28/SM4%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/","excerpt":"","text":"SM4 介绍SM4 算法是中华人民共和国政府采用的一种分组密码标准，由国家密码管理局于2012年3月21日发布。相关标准为“GM/T 0002-2012《SM4分组密码算法》”。本质是一个对称分组加密算法，类似于 DES 或者 AES。它的的分组长度为 128bit，密钥长度为 128bit。算法先由已知秘钥生成轮秘钥 rk，然后与被 S-box 加密后的明文 X 进行 32 轮轮变换，生成密文。解密只需将轮秘钥倒序再进行 32 轮轮变换即可，代码仓库 具体实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596func S(a uint32) uint32 &#123; // 通过S盒置换字 var aArr [4]byte var bArr [4]byte binary.BigEndian.PutUint32(aArr[:], a) bArr[0] = sBox[aArr[0]] bArr[1] = sBox[aArr[1]] bArr[2] = sBox[aArr[2]] bArr[3] = sBox[aArr[3]] return binary.BigEndian.Uint32(bArr[:])&#125;func L(b uint32) uint32 &#123; // L变换 return b ^ bits.RotateLeft32(b, 2) ^ bits.RotateLeft32(b, 10) ^ bits.RotateLeft32(b, 18) ^ bits.RotateLeft32(b, 24)&#125;func T(z uint32) uint32 &#123; // T变换 return L(S(z))&#125;func lRk(b uint32) uint32 &#123; // rk的L变换 return b ^ bits.RotateLeft32(b, 13) ^ bits.RotateLeft32(b, 23)&#125;func tRk(z uint32) uint32 &#123; // rk的T变换 return lRk(S(z))&#125;func reverse(a []uint32) &#123; //反转数组 a[0], a[3] = a[3], a[0] a[1], a[2] = a[2], a[1]&#125;func expandKey(key []byte) []uint32 &#123; // 生成轮秘钥rk mK := make([]uint32, 4) mK[0] = binary.BigEndian.Uint32(key[0:4]) // 将四个字节转为一个字 mK[1] = binary.BigEndian.Uint32(key[4:8]) mK[2] = binary.BigEndian.Uint32(key[8:12]) mK[3] = binary.BigEndian.Uint32(key[12:16]) k := make([]uint32, 36) k[0] = mK[0] ^ fK[0] // 主密钥与中系统参数fk异或得到中间数据k k[1] = mK[1] ^ fK[1] k[2] = mK[2] ^ fK[2] k[3] = mK[3] ^ fK[3] rk := make([]uint32, 32) for i := 0; i &lt; 32; i++ &#123; // 计算rk[i] k[i+4] = k[i] ^ tRk(k[i+1]^k[i+2]^k[i+3]^cK[i]) rk[i] = k[i+4] &#125; return rk&#125;func initX(text []byte) []uint32 &#123; // 初始化x x := make([]uint32, 36) x[0] = binary.BigEndian.Uint32(text[0:4]) x[1] = binary.BigEndian.Uint32(text[4:8]) x[2] = binary.BigEndian.Uint32(text[8:12]) x[3] = binary.BigEndian.Uint32(text[12:16]) return x&#125;func encrypt(x []uint32, rk []uint32) []uint32 &#123; // 加密操作：32次轮函数 + 1次反转 for i := 0; i &lt; 32; i++ &#123; x[i+4] = x[i] ^ T(x[i+1]^x[i+2]^x[i+3]^rk[i]) &#125; reverse(x[32:]) return x[32:]&#125;func decrypt(res []uint32, rk []uint32) []uint32 &#123; // 解密操作：32次轮函数(rk 从后往前) + 1次反转 x := make([]uint32, 36) x[0] = res[0] //将res转移为新的x x[1] = res[1] x[2] = res[2] x[3] = res[3] for i := 0; i &lt; 32; i++ &#123; x[i+4] = x[i] ^ T(x[i+1]^x[i+2]^x[i+3]^rk[31-i]) &#125; reverse(x[32:]) return x[32:]&#125;func Padding(text []byte, blockSize int) []byte &#123; // 尾部填充 length := blockSize - len(text)%blockSize padText := bytes.Repeat([]byte&#123;byte(length)&#125;, length) return append(text, padText...)&#125;func UnPadding(text []byte) []byte &#123; // 删除填充 length := len(text) padLength := int(text[length-1]) return text[:(length - padLength)]&#125;© 2020 GitHub, Inc.","categories":[],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://yoursite.com/tags/Golang/"},{"name":"Crypto","slug":"Crypto","permalink":"http://yoursite.com/tags/Crypto/"}],"author":"kqzh"},{"title":"Hello World","slug":"hello-world","date":"2020-03-27T09:31:34.000Z","updated":"2020-03-31T09:46:56.830Z","comments":true,"path":"2020/03/27/hello-world/","link":"","permalink":"http://yoursite.com/2020/03/27/hello-world/","excerpt":"","text":"REPOST 1234567import \"fmt\"func main() &#123; fmt.Println(\"hello, world\") &#125;","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"Golang","slug":"Golang","permalink":"http://yoursite.com/tags/Golang/"},{"name":"Crypto","slug":"Crypto","permalink":"http://yoursite.com/tags/Crypto/"}]}